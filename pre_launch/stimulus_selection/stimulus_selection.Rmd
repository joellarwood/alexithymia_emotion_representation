---
title: "Stimulius Selection"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: console
---


I am taking stimulus from the MediaEval dataset. This data is pre annotated in terms of expressed valence and arousal. For inclusion in my study the stimulus must be in the inner or outer tertile of rated songs. From here I will randomly downsample by genre to match the smalled category and randomly sample down to 8 stimuli per quotient. 

```{r warnings = FALSE, message = FALSE}
library(tidyverse)
library(here)
library(ggforce)
library(cowplot)
```


```{r echo = TRUE}

media_eval <- read_csv(here::here(
  "pre_launch",
  "stimulus_selection",
  "annotations",
  "static_annotations.csv"
))

tertile_valence <- quantile(media_eval$mean_valence, c(.333, .666))
tertile_arousal <- quantile(media_eval$mean_arousal, c(.333, .666))


media_eval_filter <- media_eval %>%
  filter(!between(mean_valence, tertile_valence[1], tertile_valence[2]) &
    !between(mean_arousal, tertile_arousal[1], tertile_arousal[2]))

ggplot2::ggplot(
  media_eval_filter,
  aes(
    x = mean_valence,
    y = mean_arousal
  )
) + 
  geom_point() +
  theme_classic()
```

This gives me the sample of appropriate songs. Now I want to sample down but statify based on genre. 

```{r}
candidate_songs <- read_csv(here::here(
  "pre_launch",
  "stimulus_selection",
  "annotations",
  "songs_info.csv"
)) %>%
  inner_join(media_eval_filter) %>%
  mutate(level = case_when(
    mean_arousal < tertile_arousal[1] &
      mean_valence < tertile_valence[1] ~ "Low Valence / Low Arousal",
    mean_arousal < tertile_arousal[1] &
      mean_valence > tertile_valence[2] ~ "High Valence / Low Arousal",
    mean_arousal > tertile_arousal[2] &
      mean_valence > tertile_valence[2] ~ "High Valence / High Arousal",
    mean_arousal > tertile_arousal[2] &
      mean_valence < tertile_valence[1] ~ "Low Valence / High Arousal"
  ))

table(candidate_songs$level, candidate_songs$Genre) %>%
  knitr::kable(caption = "Candidate songs by Genre")
```

So based on this I need to down stratify based on this criteria:   
  0 blues songs  
  1 classical song per level  
  2 country songs per level   
  2 folk songs per level  
  1 jazz song per level 
  1 pop song per level 
  1 rock song per level
  
  
```{r}

set.seed(1234)

classical <- candidate_songs %>%
  filter(Genre == "Classical") %>%
  group_by(level) %>%
  dplyr::sample_n(1)

country <- candidate_songs %>%
  filter(Genre == "Country") %>%
  group_by(level) %>%
  dplyr::sample_n(2)

folk <- candidate_songs %>%
  filter(Genre == "Folk") %>%
  group_by(level) %>%
  dplyr::sample_n(2)

jazz <- candidate_songs %>%
  filter(Genre == "Jazz") %>%
  group_by(level) %>%
  dplyr::sample_n(1)

pop <- candidate_songs %>%
  filter(Genre == "Pop") %>%
  group_by(level) %>%
  dplyr::sample_n(1)

rock <- candidate_songs %>%
  filter(Genre == "Rock") %>%
  group_by(level) %>%
  dplyr::sample_n(1)


selected_songs <- bind_rows(
  classical,
  folk,
  country,
  pop,
  rock,
  jazz
) %>%
  ungroup()

table(selected_songs$level, selected_songs$Genre) %>%
  knitr::kable(caption = "Selected songs by Genre")

selected_songs %>%
  ggplot2::ggplot(aes(
    x = mean_valence,
    y = mean_arousal,
    color = Genre,
    shape = level,
    label = paste("V =", selected_songs$mean_valence, "A =", selected_songs$mean_arousal)
  )) +
  ggplot2::geom_point() +
  ylim(1, 9) +
  xlim(1, 9) +
  geom_vline(xintercept = tertile_valence[1]) +
  geom_vline(xintercept = tertile_valence[2]) + 
  geom_hline(yintercept = tertile_arousal[1]) +
  geom_hline(yintercept =tertile_arousal[2]) +
  ggplot2::geom_point() +
  ggplot2::theme_classic()
```


Now I am going to read in the ratings over time 
```{r}

valence_over_time <- read_csv(here::here(
  "pre_launch",
  "stimulus_selection",
  "annotations",
  "valence_cont_average.csv"
)) %>%
  inner_join(selected_songs) %>%
  pivot_longer(
    cols = contains("sample"),
    names_to = "time",
    values_to = "valence"
  ) %>%
  mutate(
    time = str_remove(time, "sample_"),
    time = str_remove(time, "ms"),
    song_id = as.factor(song_id),
    time = as.numeric(time)
    ) %>%
  select(
    level,
    song_id,
    time,
    valence
  )

valence_plot <- ggplot2::ggplot(
  valence_over_time,
  aes(
    x = time,
    y = valence,
    group = song_id
  )
) +
  ggplot2::geom_line(aes(color = level)) +
  ggplot2::theme_classic() +
  ggplot2::theme(legend.position = "none") +
  ylim(c(-.75, .75)) +
  ggplot2::scale_x_continuous(breaks = c(
    15000,
    20000,
    25000,
    30000,
    35000,
    40000,
    45000
  )) + 
  ggrepel::geom_text_repel(label = glue::glue())

arousal_over_time <- read_csv(here::here(
  "pre_launch",
  "stimulus_selection",
  "annotations",
  "arousal_cont_average.csv"
)) %>%
  inner_join(selected_songs) %>%
  pivot_longer(
    cols = contains("sample"),
    names_to = "time",
    values_to = "arousal"
  ) %>%
  mutate(
    time = str_remove(time, "sample_"),
    time = str_remove(time, "ms"),
    song_id = as.factor(song_id),
    time = as.numeric(time)
  ) %>%
  select(
    level,
    song_id,
    time,
    arousal
  )

arousal_plot <- ggplot2::ggplot(
  arousal_over_time,
  aes(
    x = time,
    y = arousal,
    group = song_id
  )
) +
  ggplot2::geom_line(aes(color = level)) +
  ggplot2::theme_classic()  +
  ggplot2::theme(legend.position = "bottom") +
  ylim(c(-.75, .75)) +
  ggplot2::scale_x_continuous(breaks = c(
    15000,
    20000,
    25000,
    30000,
    35000,
    40000,
    45000
  ))

arousal_no_legend <- arousal_plot + 
  ggplot2::theme(legend.position = "none")

plots <- cowplot::plot_grid(valence_plot, 
                   arousal_no_legend, 
                   nrow = 2)

legend <- cowplot::get_legend(arousal_plot)

cowplot::plot_grid(plots, 
                   legend, 
                   nrow = 2, 
                   rel_heights = c(4, .2
                                   ))
```

Finally I want two random 5 second snippets of each song. I will do this using an R script. with the starting point of each song being 5 seconds post a random time point between 15 and 40 seconds 

```{r}
print(selected_songs$file_name) 
```


